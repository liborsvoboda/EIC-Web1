/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

import{$generateHtmlFromNodes as t,$generateNodesFromDOM as e}from"@lexical/html";import{$addNodeStyle as n,$sliceSelectedTextNodeContent as o}from"@lexical/selection";import{objectKlassEquals as l}from"@lexical/utils";import{$getSelection as r,$isRangeSelection as i,$createTabNode as s,SELECTION_INSERT_CLIPBOARD_NODES_COMMAND as a,$getRoot as c,$parseSerializedNode as u,$isTextNode as d,COPY_COMMAND as f,COMMAND_PRIORITY_CRITICAL as p,isSelectionWithinEditor as m,$isElementNode as h,$cloneWithProperties as g}from"lexical";function x(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}var w=x((function(t){const e=new URLSearchParams;e.append("code",t);for(let t=1;t<arguments.length;t++)e.append("v",arguments[t]);throw Error(`Minified Lexical error #${t}; visit https://lexical.dev/docs/error?${e} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`)}));const y="undefined"!=typeof window&&void 0!==window.document&&void 0!==window.document.createElement,v=t=>y?(t||window).getSelection():null;function D(e){const n=r();return null==n&&w(166),i(n)&&n.isCollapsed()||0===n.getNodes().length?"":t(e,n)}function C(t){const e=r();return null==e&&w(166),i(e)&&e.isCollapsed()||0===e.getNodes().length?null:JSON.stringify(A(t,e))}function N(t,e){const n=t.getData("text/plain")||t.getData("text/uri-list");null!=n&&e.insertRawText(n)}function _(t,n,o){const l=t.getData("application/x-lexical-editor");if(l)try{const t=JSON.parse(l);if(t.namespace===o._config.namespace&&Array.isArray(t.nodes)){return T(o,R(t.nodes),n)}}catch(t){}const a=t.getData("text/html");if(a)try{const t=(new DOMParser).parseFromString(a,"text/html");return T(o,e(o,t),n)}catch(t){}const c=t.getData("text/plain")||t.getData("text/uri-list");if(null!=c)if(i(n)){const t=c.split(/(\r?\n|\t)/);""===t[t.length-1]&&t.pop();for(let e=0;e<t.length;e++){const n=r();if(i(n)){const o=t[e];"\n"===o||"\r\n"===o?n.insertParagraph():"\t"===o?n.insertNodes([s()]):n.insertText(o)}}}else n.insertRawText(c)}function T(t,e,n){t.dispatchCommand(a,{nodes:e,selection:n})||n.insertNodes(e)}function S(t,e,n,l=[]){let r=null===e||n.isSelected(e);const i=h(n)&&n.excludeFromCopy("html");let s=n;if(null!==e){let t=g(n);t=d(t)&&null!==e?o(e,t):t,s=t}const a=h(s)?s.getChildren():[],c=function(t){const e=t.exportJSON(),n=t.constructor;if(e.type!==n.getType()&&w(58,n.name),h(t)){const t=e.children;Array.isArray(t)||w(59,n.name)}return e}(s);if(d(s)){const t=s.__text;t.length>0?c.text=t:r=!1}for(let o=0;o<a.length;o++){const l=a[o],i=S(t,e,l,c.children);!r&&h(n)&&i&&n.extractWithChild(l,e,"clone")&&(r=!0)}if(r&&!i)l.push(c);else if(Array.isArray(c.children))for(let t=0;t<c.children.length;t++){const e=c.children[t];l.push(e)}return r}function A(t,e){const n=[],o=c().getChildren();for(let l=0;l<o.length;l++){S(t,e,o[l],n)}return{namespace:t._config.namespace,nodes:n}}function R(t){const e=[];for(let o=0;o<t.length;o++){const l=t[o],r=u(l);d(r)&&n(r),e.push(r)}return e}let E=null;async function O(t,e){if(null!==E)return!1;if(null!==e)return new Promise(((n,o)=>{t.update((()=>{n(P(t,e))}))}));const n=t.getRootElement(),o=null==t._window?window.document:t._window.document,r=v(t._window);if(null===n||null===r)return!1;const i=o.createElement("span");i.style.cssText="position: fixed; top: -1000px;",i.append(o.createTextNode("#")),n.append(i);const s=new Range;return s.setStart(i,0),s.setEnd(i,1),r.removeAllRanges(),r.addRange(s),new Promise(((e,n)=>{const r=t.registerCommand(f,(n=>(l(n,ClipboardEvent)&&(r(),null!==E&&(window.clearTimeout(E),E=null),e(P(t,n))),!0)),p);E=window.setTimeout((()=>{r(),E=null,e(!1)}),50),o.execCommand("copy"),i.remove()}))}function P(t,e){const n=v(t._window);if(!n)return!1;const o=n.anchorNode,l=n.focusNode;if(null!==o&&null!==l&&!m(t,o,l))return!1;e.preventDefault();const i=e.clipboardData,s=r();if(null===i||null===s)return!1;const a=D(t),c=C(t);let u="";return null!==s&&(u=s.getTextContent()),null!==a&&i.setData("text/html",a),null!==c&&i.setData("application/x-lexical-editor",c),i.setData("text/plain",u),!0}export{A as $generateJSONFromSelectedNodes,R as $generateNodesFromSerializedNodes,D as $getHtmlContent,C as $getLexicalContent,N as $insertDataTransferForPlainText,_ as $insertDataTransferForRichText,T as $insertGeneratedNodes,O as copyToClipboard};
